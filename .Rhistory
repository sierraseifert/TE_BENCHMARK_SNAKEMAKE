stop("STOP! There are values in the V5 column that are not in your
classification scheme: ",
paste(unique(invalid_values), collapse = ", "))
}
write.table(rmdf, file = rmcsv, row.names = FALSE, col.names = FALSE, sep = ",")
}
clean_rmgff(input_gff, input_fasta, output_csv, seq_name)
setwd("~/TE_BENCHMARKING_SNAKEMAKE/scripts")
setwd("~/TE_BENCHMARKING_SNAKEMAKE")
# this script converts a 9 column gff from RepeatModeler2 to a 7 column csv
# for ease of downstream analysis
# output csv schema (rmcsv):
# V1: sequence name
# V2: "RepeatModeler2"
# V3: start
# V4: end
# V5: type
# V6: subtype
# V7: family # OR motif
# V8: if V5 = "LINE-dependent" or "Non-TE," additional info stored here
##########################################################################
# load libraries
library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(Biostrings)
library(yaml)
##########################################################################
# gather input
config <- yaml.load_file("config.yaml")
input_gff <- config$RM2_gff
input_fasta <- config$RM2_fasta
output_csv <- sub("\\.gff$", ".csv", input_gff)
seq_name <- config$seq_name
##########################################################################
clean_rmgff <- function(rmgff, rmfasta, rmcsv, name) {
# convert gff to data frame
rmdf <- as.data.frame(read.csv(rmgff, sep = "\t", header = 0))
# delete top 2 rows containing metadata
rmdf <- rmdf[-c(1, 2), ]
# set all values in V1 to name
rmdf$V1 <- name
# set all values in V2 to "RepeatModeler2"
rmdf$V2 <- "RepeatModeler2"
# keep V3 data in case (dispersed_repeat value, anything else?)
keep <- rmdf$V3
# shift start and end locations to V3 and V4
rmdf$V3 <- rmdf$V4
rmdf$V4 <- rmdf$V5
# condense V9 values to family numbers to prepare for merge
rmdf$V9 <- sub(".*Target Motif:([^ ]+).*", "\\1", rmdf$V9)
# read fasta file to extract classification info by merging on family number
seqs <- readDNAStringSet(rmfasta)
titles <- names(seqs)
split_titles <- strsplit(titles, "#")
fastadf <- data.frame(
number = sapply(split_titles, function(x) trimws(x[1])),
type = sapply(split_titles, function(x) trimws(x[2])),
stringsAsFactors = FALSE
)
# merge fastadf and rmdf on family number
fastadf$type <- sub("\\s*\\(.*", "", fastadf$type)
rmdf <- merge(rmdf, fastadf, by.x = "V9", by.y = "number", all.x = TRUE)
# move type to V5
rmdf$V5 <- rmdf$type
# delete unnecessary columns and re order
rmdf <- rmdf %>%
select(-V9, -V7, -V8, -type, V9)
colnames(rmdf)[which(colnames(rmdf) == "V9")] <- "V7"
# if subtype exists, move it to V6
rmdf$V6 <- NA
rows_with_subtype <- grepl("/", rmdf$V5)
rmdf$V6[rows_with_subtype] <- sub(".*?/", "", rmdf$V5[rows_with_subtype])
rmdf$V5[rows_with_subtype] <- sub("/.*", "", rmdf$V5[rows_with_subtype])
# store in V8 what we're about to write over in V5
rmdf$V8 <- rmdf$V5
# replace tRNA, rRNA, snRNA, scRNA, Simple_repeat, and Satellite with Non-TE
rmdf$V5[is.na(rmdf$V5)] <- "Non-TE"
rmdf$V5 <- gsub("^(tRNA|rRNA|snRNA|scRNA|Simple_repeat|Satellite)$", "Non-TE", rmdf$V5)
# replace SINE and Retroposon with LINE-dependent
rmdf$V5 <- gsub("^(SINE|Retroposon)$", "LINE-dependent", rmdf$V5)
# replace RC with DNA
rmdf$V5 <- gsub("^(RC)$", "DNA", rmdf$V5)
# replace values containing "?" with Unknown
rmdf$V5 <- ifelse(grepl("\\?", rmdf$V5), "Unknown", rmdf$V5)
# raise error if there are remaining types not in our classification scheme
invalid_values <- rmdf$V5[!rmdf$V5 %in% c("Non-TE", "Unknown", "DNA", "LTR", "LINE", "LINE-dependent")]
if (length(invalid_values) > 0) {
stop("STOP! There are values in the V5 column that are not in your
classification scheme: ",
paste(unique(invalid_values), collapse = ", "))
}
write.table(rmdf, file = rmcsv, row.names = FALSE, col.names = FALSE, sep = ",")
}
clean_rmgff(input_gff, input_fasta, output_csv, seq_name)
# this script converts a 9 column gff from RepeatModeler2 to a 7 column csv
# for ease of downstream analysis
# output csv schema (rmcsv):
# V1: sequence name
# V2: "RepeatModeler2"
# V3: start
# V4: end
# V5: type
# V6: subtype
# V7: family # OR motif
# V8: if V5 = "LINE-dependent" or "Non-TE," additional info stored here
##########################################################################
# load libraries
library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(Biostrings)
library(yaml)
##########################################################################
# gather input
config <- yaml.load_file("config.yaml")
input_gff <- config$RM2_gff
input_fasta <- config$RM2_fasta
output_csv <- sub("\\.gff$", ".csv", input_gff)
print(output_csv)
seq_name <- config$seq_name
##########################################################################
clean_rmgff <- function(rmgff, rmfasta, rmcsv, name) {
# convert gff to data frame
rmdf <- as.data.frame(read.csv(rmgff, sep = "\t", header = 0))
# delete top 2 rows containing metadata
rmdf <- rmdf[-c(1, 2), ]
# set all values in V1 to name
rmdf$V1 <- name
# set all values in V2 to "RepeatModeler2"
rmdf$V2 <- "RepeatModeler2"
# keep V3 data in case (dispersed_repeat value, anything else?)
keep <- rmdf$V3
# shift start and end locations to V3 and V4
rmdf$V3 <- rmdf$V4
rmdf$V4 <- rmdf$V5
# condense V9 values to family numbers to prepare for merge
rmdf$V9 <- sub(".*Target Motif:([^ ]+).*", "\\1", rmdf$V9)
# read fasta file to extract classification info by merging on family number
seqs <- readDNAStringSet(rmfasta)
titles <- names(seqs)
split_titles <- strsplit(titles, "#")
fastadf <- data.frame(
number = sapply(split_titles, function(x) trimws(x[1])),
type = sapply(split_titles, function(x) trimws(x[2])),
stringsAsFactors = FALSE
)
# merge fastadf and rmdf on family number
fastadf$type <- sub("\\s*\\(.*", "", fastadf$type)
rmdf <- merge(rmdf, fastadf, by.x = "V9", by.y = "number", all.x = TRUE)
# move type to V5
rmdf$V5 <- rmdf$type
# delete unnecessary columns and re order
rmdf <- rmdf %>%
select(-V9, -V7, -V8, -type, V9)
colnames(rmdf)[which(colnames(rmdf) == "V9")] <- "V7"
# if subtype exists, move it to V6
rmdf$V6 <- NA
rows_with_subtype <- grepl("/", rmdf$V5)
rmdf$V6[rows_with_subtype] <- sub(".*?/", "", rmdf$V5[rows_with_subtype])
rmdf$V5[rows_with_subtype] <- sub("/.*", "", rmdf$V5[rows_with_subtype])
# store in V8 what we're about to write over in V5
rmdf$V8 <- rmdf$V5
# replace tRNA, rRNA, snRNA, scRNA, Simple_repeat, and Satellite with Non-TE
rmdf$V5[is.na(rmdf$V5)] <- "Non-TE"
rmdf$V5 <- gsub("^(tRNA|rRNA|snRNA|scRNA|Simple_repeat|Satellite)$", "Non-TE", rmdf$V5)
# replace SINE and Retroposon with LINE-dependent
rmdf$V5 <- gsub("^(SINE|Retroposon)$", "LINE-dependent", rmdf$V5)
# replace RC with DNA
rmdf$V5 <- gsub("^(RC)$", "DNA", rmdf$V5)
# replace values containing "?" with Unknown
rmdf$V5 <- ifelse(grepl("\\?", rmdf$V5), "Unknown", rmdf$V5)
# raise error if there are remaining types not in our classification scheme
invalid_values <- rmdf$V5[!rmdf$V5 %in% c("Non-TE", "Unknown", "DNA", "LTR", "LINE", "LINE-dependent")]
if (length(invalid_values) > 0) {
stop("STOP! There are values in the V5 column that are not in your
classification scheme: ",
paste(unique(invalid_values), collapse = ", "))
}
write.table(rmdf, file = rmcsv, row.names = FALSE, col.names = FALSE, sep = ",")
}
clean_rmgff(input_gff, input_fasta, output_csv, seq_name)
# this script converts a 9 column gff from RepeatModeler2 to a 7 column csv
# for ease of downstream analysis
# output csv schema (rmcsv):
# V1: sequence name
# V2: "RepeatModeler2"
# V3: start
# V4: end
# V5: type
# V6: subtype
# V7: family # OR motif
# V8: if V5 = "LINE-dependent" or "Non-TE," additional info stored here
##########################################################################
# load libraries
library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(Biostrings)
library(yaml)
##########################################################################
# gather input
config <- yaml.load_file("config.yaml")
input_gff <- config$RM2_gff
input_fasta <- config$RM2_fasta
output_csv <- sub("input/", "output/", input_gff)
output_csv <- sub("\\.gff$", ".csv", output_csv)
seq_name <- config$seq_name
##########################################################################
clean_rmgff <- function(rmgff, rmfasta, rmcsv, name) {
# convert gff to data frame
rmdf <- as.data.frame(read.csv(rmgff, sep = "\t", header = 0))
# delete top 2 rows containing metadata
rmdf <- rmdf[-c(1, 2), ]
# set all values in V1 to name
rmdf$V1 <- name
# set all values in V2 to "RepeatModeler2"
rmdf$V2 <- "RepeatModeler2"
# keep V3 data in case (dispersed_repeat value, anything else?)
keep <- rmdf$V3
# shift start and end locations to V3 and V4
rmdf$V3 <- rmdf$V4
rmdf$V4 <- rmdf$V5
# condense V9 values to family numbers to prepare for merge
rmdf$V9 <- sub(".*Target Motif:([^ ]+).*", "\\1", rmdf$V9)
# read fasta file to extract classification info by merging on family number
seqs <- readDNAStringSet(rmfasta)
titles <- names(seqs)
split_titles <- strsplit(titles, "#")
fastadf <- data.frame(
number = sapply(split_titles, function(x) trimws(x[1])),
type = sapply(split_titles, function(x) trimws(x[2])),
stringsAsFactors = FALSE
)
# merge fastadf and rmdf on family number
fastadf$type <- sub("\\s*\\(.*", "", fastadf$type)
rmdf <- merge(rmdf, fastadf, by.x = "V9", by.y = "number", all.x = TRUE)
# move type to V5
rmdf$V5 <- rmdf$type
# delete unnecessary columns and re order
rmdf <- rmdf %>%
select(-V9, -V7, -V8, -type, V9)
colnames(rmdf)[which(colnames(rmdf) == "V9")] <- "V7"
# if subtype exists, move it to V6
rmdf$V6 <- NA
rows_with_subtype <- grepl("/", rmdf$V5)
rmdf$V6[rows_with_subtype] <- sub(".*?/", "", rmdf$V5[rows_with_subtype])
rmdf$V5[rows_with_subtype] <- sub("/.*", "", rmdf$V5[rows_with_subtype])
# store in V8 what we're about to write over in V5
rmdf$V8 <- rmdf$V5
# replace tRNA, rRNA, snRNA, scRNA, Simple_repeat, and Satellite with Non-TE
rmdf$V5[is.na(rmdf$V5)] <- "Non-TE"
rmdf$V5 <- gsub("^(tRNA|rRNA|snRNA|scRNA|Simple_repeat|Satellite)$", "Non-TE", rmdf$V5)
# replace SINE and Retroposon with LINE-dependent
rmdf$V5 <- gsub("^(SINE|Retroposon)$", "LINE-dependent", rmdf$V5)
# replace RC with DNA
rmdf$V5 <- gsub("^(RC)$", "DNA", rmdf$V5)
# replace values containing "?" with Unknown
rmdf$V5 <- ifelse(grepl("\\?", rmdf$V5), "Unknown", rmdf$V5)
# raise error if there are remaining types not in our classification scheme
invalid_values <- rmdf$V5[!rmdf$V5 %in% c("Non-TE", "Unknown", "DNA", "LTR", "LINE", "LINE-dependent")]
if (length(invalid_values) > 0) {
stop("STOP! There are values in the V5 column that are not in your
classification scheme: ",
paste(unique(invalid_values), collapse = ", "))
}
write.table(rmdf, file = rmcsv, row.names = FALSE, col.names = FALSE, sep = ",")
}
clean_rmgff(input_gff, input_fasta, output_csv, seq_name)
# this script converts a 9 column gff from Garlic to a 7 column csv
# for ease of downstream analysis
# output csv schema (garliccsv):
# V1: sequence name
# V2: "Reference (Garlic)"
# V3: start
# V4: end
# V5: type
# V6: subtype
# V7: family # OR motif
# V8: if V5 = "LINE-dependent" or "Non-TE," additional info stored here
##########################################################################
# load libraries
library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(Biostrings)
library(yaml)
##########################################################################
# gather input
config <- yaml.load_file("config.yaml")
input_gff <- config$Garlic_gff
output_csv <- sub("input/", "output/", input_gff)
output_csv <- sub("\\.gff$", ".csv", output_csv)
seq_name <- config$seq_name
##########################################################################
clean_garlicgff <- function(garlicgff, garliccsv, name) {
# convert gff to data frame
garlicdf <- as.data.frame(read.csv(garlicgff, sep = "\t", header = 0))
# set all values in V1 to name
garlicdf$V1 <- name
# set all values in V2 to Reference (Garlic)"
garlicdf$V2 <- "Reference (Garlic)"
# save feature, start and end columns
feature <- garlicdf$V3
start <- garlicdf$V4
end <- garlicdf$V5
# shift start and end locations to V3 and V4
garlicdf$V3 <- start
garlicdf$V4 <- end
garlicdf$V5 <- feature
# for all rows with no information on subtype, set V6 to NA
rows_wo_subclass <- !grepl("/", garlicdf$V5)
garlicdf$V7[rows_wo_subclass] <- str_extract(garlicdf$V5[rows_wo_subclass], "^[^:]+")
garlicdf$V5[rows_wo_subclass] <- str_extract(garlicdf$V5[rows_wo_subclass], "(?<=:).*")
garlicdf$V6[rows_wo_subclass] <- NA
# clean the rest of the rows such that V5 is type, V6 is subtype,
# and V7 is family
rows_w_colon <- grepl(":", garlicdf$V5)
garlicdf <- garlicdf %>%
mutate(
family = str_extract(V5, "^[^:]+"),
type = str_extract(V5, "(?<=:)[^/]+"),
subtype = str_extract(V5, "(?<=/).*")
) %>%
mutate(
V7 = ifelse(grepl(":", V5), family, V7),
V6 = ifelse(grepl(":", V5), subtype, V6),
V5 = ifelse(grepl(":", V5), type, V5)
)
# delete unnecessary columns
garlicdf <- garlicdf %>%
select(-V8, -V9, -family, -type, -subtype)
# store in V8 what we're about to write over in V5
garlicdf$V8 <- garlicdf$V5
# replace SINE and Retroposon with LINE-dependent
garlicdf$V5 <- gsub("^(SINE|Retroposon)$", "LINE-dependent", garlicdf$V5)
# replace tRNA, snRNA, rRNA, RNA, and scRNA with Non-TE
garlicdf$V5 <- gsub("^(tRNA|snRNA|rRNA|RNA|scRNA)$", "Non-TE", garlicdf$V5)
# replace RC with DNA
garlicdf$V5 <- gsub("^(RC)$", "DNA", garlicdf$V5)
# replace Other YPRIME with DNA YPRIME
garlicdf$V5[garlicdf$V7 == "YPRIME"] <- "DNA"
# replace Other NTS_DM with Non-TE NTS_DM
garlicdf$V5[garlicdf$V7 == "NTS_DM"] <- "Non-TE"
# replace values containing "?" with Unknown
garlicdf$V5 <- ifelse(grepl("\\?", garlicdf$V5), "Unknown", garlicdf$V5)
# raise error if there are remaining types not in our classification scheme
invalid_values <- garlicdf$V5[!garlicdf$V5 %in% c("Unknown", "Non-TE", "DNA", "LTR", "LINE", "LINE-dependent")]
if (length(invalid_values) > 0) {
stop("Invalid values found in V5 column: ", paste(unique(invalid_values), collapse = ", "))
}
write.table(garlicdf, file = garliccsv, row.names = FALSE, col.names = FALSE, sep = ",")
}
clean_garlicgff(input_gff, output_csv, seq_name)
# this script converts a 9 column gff from Earl Grey to a 7 column csv
# for ease of downstream analysis
# output csv schema (egcsv):
# V1: sequence name
# V2: "EarlGrey"
# V3: start
# V4: end
# V5: type
# V6: subtype
# V7: family # OR motif
# V8: if V5 = "LINE-dependent" or "Non-TE," additional info stored here
##########################################################################
# load libraries
library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(Biostrings)
library(yaml)
##########################################################################
# gather input
config <- yaml.load_file("config.yaml")
input_gff <- config$EG_gff
output_csv <- sub("input/", "output/", input_gff)
output_csv <- sub("\\.gff$", ".csv", output_csv)
seq_name <- config$seq_name
##########################################################################
clean_eggff <- function(eggff, egcsv, name) {
# convert gff to data frame
egdf <- as.data.frame(read.csv(eggff, sep = "\t", header = 0))
# set all values in V1 to name
egdf$V1 <- name
# set all values in V2 to "EarlGrey"
egdf$V2 <- "EarlGrey"
# save feature, start and end columns
feature <- egdf$V3
start <- egdf$V4
end <- egdf$V5
# shift start and end locations to V3 and V4
egdf$V3 <- start
egdf$V4 <- end
egdf$V5 <- feature
# clean V5 and V6 such that they are type and subtype, respectively
egdf <- egdf %>%
mutate(V5_split = str_split(V5, "/")) %>%
mutate(
new_col1 = map_chr(V5_split, ~ .x[1]),
new_col2 = map_chr(V5_split, ~ ifelse(length(.x) > 1, .x[2], NA))
) %>%
select(-V5_split)
type <- egdf$new_col1
subtype <- egdf$new_col2
egdf$V5 <- type
egdf$V6 <- subtype
# clean V7 (note that simple repeats don't have family #s)
egdf <- egdf %>%
mutate(V7 = as.numeric(str_extract(V9, "(?<=FAMILY-)\\d+")))
# delete unnecessary columns
egdf <- egdf %>%
select(-V8, -V9, -new_col1, -new_col2)
# store in V8 what we're about to write over in V5
egdf$V8 <- egdf$V5
# replace SINE and Retroposon with LINE-dependent
egdf$V5 <- gsub("^(SINE|Retroposon)$", "LINE-dependent", egdf$V5)
# replace RC with DNA
egdf$V5 <- gsub("^(RC)$", "DNA", egdf$V5)
# replace Simple_repeat, Low_complexity, and Satellite with Non-TE
egdf$V5 <- gsub("^(Simple_repeat|Low_complexity|Satellite)$", "Non-TE", egdf$V5)
# raise error if there are remaining types not in our classification scheme
invalid_values <- egdf$V5[!egdf$V5 %in% c("Unknown", "Non-TE", "DNA", "LTR", "LINE", "LINE-dependent")]
if (length(invalid_values) > 0) {
stop("Invalid values found in V5 column: ", paste(unique(invalid_values), collapse = ", "))
}
write.table(egdf, file = egcsv, row.names = FALSE, col.names = FALSE, sep = ",")
}
clean_eggff(input_gff, output_csv, seq_name)
# this script converts a 9 column gff from EDTA to a 7 column csv
# for ease of downstream analysis
# output csv schema (edtacsv):
# V1: sequence name
# V2: "EDTA"
# V3: start
# V4: end
# V5: type
# V6: subtype
# V7: family #
# V8: if V5 = "LINE-dependent" or "Non-TE," additional info stored here
##########################################################################
# load libraries
library(dplyr)
library(tidyr)
library(stringr)
library(purrr)
library(Biostrings)
library(yaml)
##########################################################################
# gather input
config <- yaml.load_file("config.yaml")
input_gff <- config$EDTA_gff
output_csv <- sub("input/", "output/", input_gff)
output_csv <- sub("\\.gff$", ".csv", output_csv)
seq_name <- config$seq_name
##########################################################################
clean_edtagff <- function(edtagff, edtacsv, name) {
gff_lines <- readLines(edtagff)[-c(1:6)]
temp_file <- tempfile()
writeLines(gff_lines, temp_file)
# convert gff to data frame
edtadf <- as.data.frame(read.csv(temp_file, sep = "\t", header = FALSE))
unlink(temp_file)
# set all values in V1 to name
edtadf$V1 <- name
# save feature, start and end columns
feature <- edtadf$V3
start <- edtadf$V4
end <- edtadf$V5
# shift start and end locations to V3 and V4
edtadf$V3 <- start
edtadf$V4 <- end
edtadf$V5 <- feature
# clean V5 and V6 such that they are type and subtype, respectively
edtadf$V5 <- ifelse(
grepl("/", edtadf$V9),
sub(".*Classification=([^/]+)\\/.*", "\\1", edtadf$V9),
sub(".*Classification=([^;]+);.*", "\\1", edtadf$V9)
)
edtadf$V6 <- ifelse(
grepl("/", edtadf$V9),  # Check if there is a '/'
sub(".*Classification=[^/]+/([^;]+);.*", "\\1", edtadf$V9),
NA
)
# clean V7 such that it is the name of the TE (TEs that have the same name
# belong to the same family?)
edtadf$V7 <- sub(".*Name=([^;]+);.*", "\\1", edtadf$V9)
# delete unnecessary columns
edtadf <- edtadf %>%
select(-V8, -V9)
# store in V8 what we're about to write over in V5
edtadf$V8 <- edtadf$V5
# replace SINE with LINE-dependent... EDTA doesn't pick up on Retroposons?
edtadf$V5 <- gsub("^(SINE)$", "LINE-dependent", edtadf$V5)
# no Non-TE classification, just Unknown repeats
# capitalize
edtadf$V5 <- gsub("^(unknown)$", "Unknown", edtadf$V5)
# replace MITE with DNA... is this valid?
edtadf$V5 <- gsub("^(MITE)$", "DNA", edtadf$V5)
# raise error if there are remaining types not in our classification scheme
invalid_values <- edtadf$V5[!edtadf$V5 %in% c("Unknown", "Non-TE", "DNA", "LTR", "LINE", "LINE-dependent")]
if (length(invalid_values) > 0) {
stop("Invalid values found in V5 column: ", paste(unique(invalid_values), collapse = ", "))
}
write.table(edtadf, file = edtacsv, row.names = FALSE, col.names = FALSE, sep = ",")
}
clean_edtagff(input_gff, output_csv, seq_name)
